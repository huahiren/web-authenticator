<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOTP 测试页面</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .test-section {
            margin: 20px 0;
        }
        label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
        }
        input {
            width: 100%;
            padding: 8px;
            margin: 5px 0 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .result {
            margin: 15px 0;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 4px;
        }
        .otp-display {
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 4px;
            margin: 10px 0;
            text-align: center;
            color: #333;
        }
        .time-left {
            text-align: center;
            color: #666;
            margin: 10px 0;
        }
        .time-bar {
            height: 4px;
            background-color: #ddd;
            margin: 10px 0;
            border-radius: 2px;
            overflow: hidden;
        }
        .time-progress {
            height: 100%;
            background-color: #4CAF50;
            width: 100%;
            transition: width 1s linear;
        }
        .test-vector {
            background-color: #f9f9f9;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        .test-vector h3 {
            margin: 0 0 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TOTP 生成测试</h1>
        
        <div class="test-section">
            <h2>基本测试</h2>
            <label for="secret">Base32 密钥：</label>
            <input type="text" id="secret" value="JBSWY3DPEHPK3PXP" placeholder="输入Base32密钥">
            
            <button onclick="testTOTP()">生成TOTP</button>
            <button onclick="startAutoRefresh()">自动刷新(30s)</button>
            <button onclick="stopAutoRefresh()">停止刷新</button>
            
            <div class="result">
                <div id="current-time" class="time-left"></div>
                <div class="time-bar">
                    <div id="time-progress" class="time-progress"></div>
                </div>
                <div id="otp-result" class="otp-display"></div>
                <div id="debug-info"></div>
            </div>
        </div>
        
        <div class="test-section">
            <h2>测试向量（RFC 6238）</h2>
            <p>使用已知的测试向量验证TOTP生成是否正确：</p>
            
            <div class="test-vector">
                <h3>测试向量 1：SHA1，30秒，6位</h3>
                <p>密钥：JBSWY3DPEHPK3PXP</p>
                <p>时间戳：1970-01-01 00:00:00 UTC (0)</p>
                <p>预期结果：287082</p>
                <button onclick="testVector1()">测试</button>
            </div>
            
            <div class="test-vector">
                <h3>测试向量 2：SHA1，30秒，6位</h3>
                <p>密钥：JBSWY3DPEHPK3PXP</p>
                <p>时间戳：2005-03-18 01:58:29 UTC (1111111109)</p>
                <p>预期结果：081804</p>
                <button onclick="testVector2()">测试</button>
            </div>
            
            <div class="test-vector">
                <h3>测试向量 3：SHA1，30秒，6位</h3>
                <p>密钥：JBSWY3DPEHPK3PXP</p>
                <p>时间戳：2005-03-18 01:58:31 UTC (1111111111)</p>
                <p>预期结果：050471</p>
                <button onclick="testVector3()">测试</button>
            </div>
        </div>
    </div>
    
    <script>
        // 复制修复后的函数
        
        // Base32解码函数
        function base32Decode(base32) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let bits = '';
            
            // 移除空格并转换为大写
            base32 = base32.replace(/\s+/g, '').toUpperCase();
            
            // 将Base32字符转换为二进制字符串
            for (let i = 0; i < base32.length; i++) {
                const index = alphabet.indexOf(base32.charAt(i));
                if (index === -1) {
                    throw new Error(`Invalid base32 character: ${base32.charAt(i)}`);
                }
                bits += index.toString(2).padStart(5, '0');
            }
            
            // 将二进制字符串转换为Uint8Array
            const bytes = [];
            for (let i = 0; i + 8 <= bits.length; i += 8) {
                bytes.push(parseInt(bits.substr(i, 8), 2));
            }
            
            return new Uint8Array(bytes);
        }
        
        // HMAC-SHA1函数
        async function hmacSHA1(key, message) {
            // 使用Web Crypto API实现HMAC-SHA1
            try {
                // 确保key是Uint8Array
                if (typeof key === 'string') {
                    const encoder = new TextEncoder();
                    key = encoder.encode(key);
                }
                
                // 确保message是Uint8Array
                if (!(message instanceof Uint8Array)) {
                    throw new Error('Message must be a Uint8Array');
                }
                
                const importedKey = await crypto.subtle.importKey(
                    'raw',
                    key,
                    { name: 'HMAC', hash: { name: 'SHA-1' } },
                    false,
                    ['sign']
                );
                
                const signature = await crypto.subtle.sign(
                    'HMAC',
                    importedKey,
                    message
                );
                
                return new Uint8Array(signature);
            } catch (error) {
                console.error('HMAC-SHA1 error:', error);
                throw error;
            }
        }
        
        // 生成TOTP
        async function generateTOTP(secret, digits = 6, period = 30, timestamp = Date.now()) {
            // 将Base32密钥转换为二进制
            const decodedSecret = base32Decode(secret);
            
            // 获取当前时间步长
            const now = Math.floor(timestamp / 1000);
            const timeStep = Math.floor(now / period);
            
            // 将时间步长转换为8字节的缓冲区（大端序）
            const buffer = new ArrayBuffer(8);
            const view = new DataView(buffer);
            // 正确处理8字节时间步长（大端序）
            for (let i = 0; i < 8; i++) {
                view.setUint8(7 - i, (timeStep >> (i * 8)) & 0xFF);
            }
            
            // 计算HMAC-SHA1
            const hmac = await hmacSHA1(decodedSecret, new Uint8Array(buffer));
            
            // 动态截断
            const offset = hmac[hmac.length - 1] & 0x0F;
            const code = ((hmac[offset] & 0x7F) << 24) |
                         ((hmac[offset + 1] & 0xFF) << 16) |
                         ((hmac[offset + 2] & 0xFF) << 8) |
                         (hmac[offset + 3] & 0xFF);
            
            // 取模得到指定长度的验证码
            const otp = code % Math.pow(10, digits);
            
            // 补前导零
            return otp.toString().padStart(digits, '0');
        }
        
        // 获取剩余时间
        function getRemainingTime(period = 30) {
            const now = Math.floor(Date.now() / 1000);
            return period - (now % period);
        }
        
        // 更新时间显示
        function updateTimeDisplay() {
            const now = new Date();
            document.getElementById('current-time').textContent = 
                `当前时间: ${now.toLocaleString()}`;
            
            const remaining = getRemainingTime();
            const progress = (remaining / 30) * 100;
            document.getElementById('time-progress').style.width = `${progress}%`;
        }
        
        // 测试TOTP生成
        async function testTOTP() {
            const secret = document.getElementById('secret').value;
            if (!secret) {
                alert('请输入Base32密钥');
                return;
            }
            
            try {
                const otp = await generateTOTP(secret);
                document.getElementById('otp-result').textContent = otp;
                updateDebugInfo(secret);
            } catch (error) {
                document.getElementById('otp-result').textContent = '错误: ' + error.message;
                console.error('测试失败:', error);
            }
        }
        
        // 更新调试信息
        async function updateDebugInfo(secret) {
            const now = Math.floor(Date.now() / 1000);
            const timeStep = Math.floor(now / 30);
            const decodedSecret = base32Decode(secret);
            
            const debugInfo = `
                <p><strong>调试信息：</strong></p>
                <p>当前时间戳(秒)：${now}</p>
                <p>时间步长：${timeStep}</p>
                <p>剩余时间：${getRemainingTime()}秒</p>
                <p>密钥长度：${secret.length}字符</p>
                <p>解码后密钥长度：${decodedSecret.length}字节</p>
            `;
            
            document.getElementById('debug-info').innerHTML = debugInfo;
        }
        
        // 自动刷新定时器
        let refreshTimer = null;
        
        // 开始自动刷新
        function startAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
            }
            
            refreshTimer = setInterval(() => {
                testTOTP();
            }, 1000);
            
            // 立即执行一次
            testTOTP();
        }
        
        // 停止自动刷新
        function stopAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
                refreshTimer = null;
            }
        }
        
        // 测试向量 1
        async function testVector1() {
            const secret = 'JBSWY3DPEHPK3PXP';
            const timestamp = 0; // 1970-01-01 00:00:00 UTC
            const expected = '287082';
            
            try {
                const otp = await generateTOTP(secret, 6, 30, timestamp * 1000);
                const result = otp === expected ? '✅ 正确' : `❌ 错误 (预期: ${expected}, 实际: ${otp})`;
                document.getElementById('otp-result').textContent = `${otp} - ${result}`;
                console.log('测试向量1:', result);
            } catch (error) {
                document.getElementById('otp-result').textContent = '错误: ' + error.message;
                console.error('测试向量1失败:', error);
            }
        }
        
        // 测试向量 2
        async function testVector2() {
            const secret = 'JBSWY3DPEHPK3PXP';
            const timestamp = 1111111109; // 2005-03-18 01:58:29 UTC
            const expected = '081804';
            
            try {
                const otp = await generateTOTP(secret, 6, 30, timestamp * 1000);
                const result = otp === expected ? '✅ 正确' : `❌ 错误 (预期: ${expected}, 实际: ${otp})`;
                document.getElementById('otp-result').textContent = `${otp} - ${result}`;
                console.log('测试向量2:', result);
            } catch (error) {
                document.getElementById('otp-result').textContent = '错误: ' + error.message;
                console.error('测试向量2失败:', error);
            }
        }
        
        // 测试向量 3
        async function testVector3() {
            const secret = 'JBSWY3DPEHPK3PXP';
            const timestamp = 1111111111; // 2005-03-18 01:58:31 UTC
            const expected = '050471';
            
            try {
                const otp = await generateTOTP(secret, 6, 30, timestamp * 1000);
                const result = otp === expected ? '✅ 正确' : `❌ 错误 (预期: ${expected}, 实际: ${otp})`;
                document.getElementById('otp-result').textContent = `${otp} - ${result}`;
                console.log('测试向量3:', result);
            } catch (error) {
                document.getElementById('otp-result').textContent = '错误: ' + error.message;
                console.error('测试向量3失败:', error);
            }
        }
        
        // 页面加载时初始化
        window.addEventListener('DOMContentLoaded', () => {
            updateTimeDisplay();
            // 每秒更新一次时间显示
            setInterval(updateTimeDisplay, 1000);
        });
    </script>
</body>
</html>