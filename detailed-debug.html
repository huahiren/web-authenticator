<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOTP 详细调试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .debug-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        .debug-section h2 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            font-size: 18px;
        }
        .debug-item {
            margin: 10px 0;
        }
        .debug-label {
            font-weight: bold;
            display: inline-block;
            width: 150px;
        }
        .debug-value {
            display: inline-block;
            background-color: #f0f8ff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
        }
        .debug-array {
            display: block;
            margin-left: 150px;
            background-color: #f0f8ff;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .otp-display {
            font-size: 48px;
            font-weight: bold;
            letter-spacing: 8px;
            text-align: center;
            margin: 20px 0;
            color: #333;
        }
        .time-left {
            text-align: center;
            color: #666;
            margin: 10px 0;
        }
        .time-bar {
            height: 6px;
            background-color: #ddd;
            margin: 10px 0;
            border-radius: 3px;
            overflow: hidden;
        }
        .time-progress {
            height: 100%;
            background-color: #4CAF50;
            width: 100%;
            transition: width 1s linear;
        }
        .test-input {
            margin: 15px 0;
        }
        .test-input label {
            display: block;
            margin: 5px 0;
            font-weight: bold;
        }
        .test-input input {
            width: 100%;
            padding: 8px;
            margin: 5px 0 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        .comparison-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #fff8e1;
            border-radius: 8px;
            border-left: 4px solid #ff9800;
        }
        .comparison-section h2 {
            margin: 0 0 15px 0;
            color: #ff9800;
            font-size: 18px;
        }
        .test-vector {
            background-color: #e8f5e8;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-vector h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2e7d32;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .test-result.success {
            background-color: #e8f5e8;
            border-left: 4px solid #4CAF50;
        }
        .test-result.error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TOTP 详细调试页面</h1>
        
        <div class="test-input">
            <h2>测试输入</h2>
            <label for="secret">Base32 密钥：</label>
            <input type="text" id="secret" value="JBSWY3DPEHPK3PXP" placeholder="输入Base32密钥">
            
            <label for="timestamp">时间戳（毫秒，留空使用当前时间）：</label>
            <input type="text" id="timestamp" placeholder="输入时间戳，如 1111111109000">
            
            <button onclick="debugTOTP()">生成并调试</button>
            <button onclick="startAutoRefresh()">自动刷新</button>
            <button onclick="stopAutoRefresh()">停止刷新</button>
            <button onclick="testStandardVectors()">测试标准向量</button>
        </div>
        
        <div class="otp-display" id="otp-result"></div>
        <div class="time-left" id="time-info"></div>
        <div class="time-bar">
            <div class="time-progress" id="time-progress"></div>
        </div>
        
        <div class="debug-section">
            <h2>TOTP 生成步骤</h2>
            
            <div class="debug-item">
                <span class="debug-label">Base32 密钥：</span>
                <span class="debug-value" id="debug-secret"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">使用时间：</span>
                <span class="debug-value" id="debug-time"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">时间戳（秒）：</span>
                <span class="debug-value" id="debug-timestamp"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">时间步长：</span>
                <span class="debug-value" id="debug-timestep"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">时间步长（十六进制）：</span>
                <span class="debug-value" id="debug-timestep-hex"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">8字节时间缓冲区：</span>
                <div class="debug-array" id="debug-time-buffer"></div>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">解码后密钥：</span>
                <div class="debug-array" id="debug-decoded-key"></div>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">HMAC-SHA1 结果：</span>
                <div class="debug-array" id="debug-hmac-result"></div>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">HMAC 长度：</span>
                <span class="debug-value" id="debug-hmac-length"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">偏移量：</span>
                <span class="debug-value" id="debug-offset"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">截断前值：</span>
                <span class="debug-value" id="debug-truncated-before"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">截断后值：</span>
                <span class="debug-value" id="debug-truncated-after"></span>
            </div>
            
            <div class="debug-item">
                <span class="debug-label">最终TOTP：</span>
                <span class="debug-value" id="debug-final-otp"></span>
            </div>
        </div>
        
        <div class="comparison-section">
            <h2>标准向量对比</h2>
            <div id="test-results"></div>
        </div>
    </div>
    
    <script>
        // 复制修复后的函数
        
        // Base32解码函数
        function base32Decode(base32) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let bits = '';
            
            // 移除空格并转换为大写
            base32 = base32.replace(/\s+/g, '').toUpperCase();
            
            // 将Base32字符转换为二进制字符串
            for (let i = 0; i < base32.length; i++) {
                const index = alphabet.indexOf(base32.charAt(i));
                if (index === -1) {
                    throw new Error(`Invalid base32 character: ${base32.charAt(i)}`);
                }
                bits += index.toString(2).padStart(5, '0');
            }
            
            // 将二进制字符串转换为Uint8Array
            const bytes = [];
            for (let i = 0; i + 8 <= bits.length; i += 8) {
                bytes.push(parseInt(bits.substr(i, 8), 2));
            }
            
            return new Uint8Array(bytes);
        }
        
        // HMAC-SHA1函数
        async function hmacSHA1(key, message) {
            // 使用Web Crypto API实现HMAC-SHA1
            try {
                // 确保key是Uint8Array
                if (typeof key === 'string') {
                    const encoder = new TextEncoder();
                    key = encoder.encode(key);
                }
                
                // 确保message是Uint8Array
                if (!(message instanceof Uint8Array)) {
                    throw new Error('Message must be a Uint8Array');
                }
                
                const importedKey = await crypto.subtle.importKey(
                    'raw',
                    key,
                    { name: 'HMAC', hash: { name: 'SHA-1' } },
                    false,
                    ['sign']
                );
                
                const signature = await crypto.subtle.sign(
                    'HMAC',
                    importedKey,
                    message
                );
                
                return new Uint8Array(signature);
            } catch (error) {
                console.error('HMAC-SHA1 error:', error);
                throw error;
            }
        }
        
        // 生成TOTP并输出调试信息
        async function debugTOTP() {
            const secret = document.getElementById('secret').value;
            const timestampInput = document.getElementById('timestamp').value;
            const timestamp = timestampInput ? parseInt(timestampInput) : Date.now();
            
            if (!secret) {
                alert('请输入Base32密钥');
                return;
            }
            
            try {
                // 更新时间显示
                updateTimeDisplay();
                
                // 1. 显示原始密钥
                document.getElementById('debug-secret').textContent = secret;
                
                // 2. 显示使用的时间
                const timeStr = new Date(timestamp).toLocaleString();
                document.getElementById('debug-time').textContent = timeStr;
                
                // 3. 计算时间戳（秒）
                const timestampSec = Math.floor(timestamp / 1000);
                document.getElementById('debug-timestamp').textContent = timestampSec;
                
                // 4. 计算时间步长
                const period = 30;
                const timeStep = Math.floor(timestampSec / period);
                document.getElementById('debug-timestep').textContent = timeStep;
                document.getElementById('debug-timestep-hex').textContent = timeStep.toString(16).padStart(8, '0');
                
                // 5. 将时间步长转换为8字节的缓冲区（大端序）
                const buffer = new ArrayBuffer(8);
                const view = new DataView(buffer);
                
                // 正确处理8字节时间步长（大端序）
                // 使用BigInt确保正确处理大数值
                let bigTimeStep = BigInt(timeStep);
                for (let i = 0; i < 8; i++) {
                    view.setUint8(7 - i, Number((bigTimeStep >> BigInt(i * 8)) & 0xFFn));
                }
                
                const timeBuffer = new Uint8Array(buffer);
                document.getElementById('debug-time-buffer').textContent = 
                    Array.from(timeBuffer).map(b => b.toString(16).padStart(2, '0')).join(' ');
                
                // 6. 解码Base32密钥
                const decodedSecret = base32Decode(secret);
                document.getElementById('debug-decoded-key').textContent = 
                    Array.from(decodedSecret).map(b => b.toString(16).padStart(2, '0')).join(' ');
                
                // 7. 计算HMAC-SHA1
                const hmac = await hmacSHA1(decodedSecret, timeBuffer);
                document.getElementById('debug-hmac-result').textContent = 
                    Array.from(hmac).map(b => b.toString(16).padStart(2, '0')).join(' ');
                document.getElementById('debug-hmac-length').textContent = hmac.length;
                
                // 8. 动态截断
                const offset = hmac[hmac.length - 1] & 0x0F;
                document.getElementById('debug-offset').textContent = offset;
                
                // 9. 计算截断前的值
                const truncatedBefore = ((hmac[offset] & 0x7F) << 24) |
                                      ((hmac[offset + 1] & 0xFF) << 16) |
                                      ((hmac[offset + 2] & 0xFF) << 8) |
                                      (hmac[offset + 3] & 0xFF);
                document.getElementById('debug-truncated-before').textContent = 
                    truncatedBefore + ' (0x' + truncatedBefore.toString(16) + ')';
                
                // 10. 计算截断后的值（取模）
                const digits = 6;
                const truncatedAfter = truncatedBefore % Math.pow(10, digits);
                document.getElementById('debug-truncated-after').textContent = 
                    truncatedAfter + ' (0x' + truncatedAfter.toString(16) + ')';
                
                // 11. 生成最终TOTP（补前导零）
                const otp = truncatedAfter.toString().padStart(digits, '0');
                document.getElementById('debug-final-otp').textContent = otp;
                document.getElementById('otp-result').textContent = otp;
                
                return otp;
            } catch (error) {
                console.error('TOTP生成失败:', error);
                document.getElementById('otp-result').textContent = '错误: ' + error.message;
                return null;
            }
        }
        
        // 获取剩余时间
        function getRemainingTime(period = 30) {
            const now = Math.floor(Date.now() / 1000);
            return period - (now % period);
        }
        
        // 更新时间显示
        function updateTimeDisplay() {
            const now = new Date();
            const remaining = getRemainingTime();
            const progress = (remaining / 30) * 100;
            
            document.getElementById('time-info').textContent = 
                `当前时间: ${now.toLocaleString()} | 剩余时间: ${remaining}秒`;
            document.getElementById('time-progress').style.width = `${progress}%`;
        }
        
        // 自动刷新定时器
        let refreshTimer = null;
        
        // 开始自动刷新
        function startAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
            }
            
            refreshTimer = setInterval(() => {
                debugTOTP();
            }, 1000);
            
            // 立即执行一次
            debugTOTP();
        }
        
        // 停止自动刷新
        function stopAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
                refreshTimer = null;
            }
        }
        
        // 测试标准向量
        async function testStandardVectors() {
            const testResults = document.getElementById('test-results');
            testResults.innerHTML = '';
            
            // RFC 6238 标准测试向量
            const testVectors = [
                {
                    name: '测试向量 1 (RFC 6238)',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: 0, // 1970-01-01 00:00:00 UTC
                    expected: '287082'
                },
                {
                    name: '测试向量 2 (RFC 6238)',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: 1111111109, // 2005-03-18 01:58:29 UTC
                    expected: '081804'
                },
                {
                    name: '测试向量 3 (RFC 6238)',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: 1111111111, // 2005-03-18 01:58:31 UTC
                    expected: '050471'
                },
                {
                    name: '测试向量 4 (RFC 6238)',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: 1234567890, // 2009-02-13 23:31:30 UTC
                    expected: '110295'
                },
                {
                    name: '测试向量 5 (RFC 6238)',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: 2000000000, // 2033-05-18 03:33:20 UTC
                    expected: '692790'
                },
                {
                    name: '测试向量 6 (RFC 6238)',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: 20000000000, // 2603-10-11 11:33:20 UTC
                    expected: '653531'
                }
            ];
            
            for (const vector of testVectors) {
                const testResult = document.createElement('div');
                testResult.className = 'test-vector';
                testResult.innerHTML = `<h3>${vector.name}</h3>`;
                
                // 生成TOTP
                const otp = await generateTOTP(vector.secret, 6, 30, vector.timestamp * 1000);
                
                const resultDiv = document.createElement('div');
                resultDiv.className = `test-result ${otp === vector.expected ? 'success' : 'error'}`;
                resultDiv.innerHTML = `
                    <p><strong>密钥:</strong> ${vector.secret}</p>
                    <p><strong>时间戳:</strong> ${vector.timestamp} (${new Date(vector.timestamp * 1000).toLocaleString()})</p>
                    <p><strong>预期结果:</strong> ${vector.expected}</p>
                    <p><strong>实际结果:</strong> ${otp}</p>
                    <p><strong>测试结果:</strong> ${otp === vector.expected ? '✅ 正确' : '❌ 错误'}</p>
                `;
                
                testResult.appendChild(resultDiv);
                testResults.appendChild(testResult);
            }
        }
        
        // 生成TOTP（仅返回结果，用于测试）
        async function generateTOTP(secret, digits = 6, period = 30, timestamp = Date.now()) {
            // 将Base32密钥转换为二进制
            const decodedSecret = base32Decode(secret);
            
            // 获取当前时间步长
            const now = Math.floor(timestamp / 1000);
            const timeStep = Math.floor(now / period);
            
            // 将时间步长转换为8字节的缓冲区（大端序）
            const buffer = new ArrayBuffer(8);
            const view = new DataView(buffer);
            // 正确处理8字节时间步长（大端序）
            for (let i = 0; i < 8; i++) {
                view.setUint8(7 - i, (timeStep >> (i * 8)) & 0xFF);
            }
            
            // 计算HMAC-SHA1
            const hmac = await hmacSHA1(decodedSecret, new Uint8Array(buffer));
            
            // 动态截断
            const offset = hmac[hmac.length - 1] & 0x0F;
            const code = ((hmac[offset] & 0x7F) << 24) |
                         ((hmac[offset + 1] & 0xFF) << 16) |
                         ((hmac[offset + 2] & 0xFF) << 8) |
                         (hmac[offset + 3] & 0xFF);
            
            // 取模得到指定长度的验证码
            const otp = code % Math.pow(10, digits);
            
            // 补前导零
            return otp.toString().padStart(digits, '0');
        }
        
        // 页面加载时初始化
        window.addEventListener('DOMContentLoaded', () => {
            updateTimeDisplay();
            // 每秒更新一次时间显示
            setInterval(updateTimeDisplay, 1000);
        });
    </script>
</body>
</html>