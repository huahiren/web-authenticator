<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HMAC一致性测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .test-result {
            margin: 20px 0;
            padding: 15px;
            border-radius: 4px;
        }
        .pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-case {
            margin: 15px 0;
            padding: 10px;
            border-left: 4px solid #007bff;
            background-color: #e3f2fd;
        }
        .test-info {
            margin: 10px 0;
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .time-info {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>HMAC一致性测试</h1>
        
        <div class="time-info">
            <h3>当前时间信息</h3>
            <p>当前时间：<span id="current-time"></span></p>
            <p>当前时间戳：<span id="current-timestamp"></span></p>
            <p>时间步长（30秒）：<span id="current-timestep"></span></p>
        </div>
        
        <button onclick="runTests()">运行测试</button>
        
        <div id="test-results"></div>
    </div>

    <script>
        // 复制script.js中的相关函数
        
        // Base32解码函数
        function base32Decode(base32) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let bits = '';
            
            // 移除空格并转换为大写
            base32 = base32.replace(/\s+/g, '').toUpperCase();
            
            // 将Base32字符转换为二进制字符串
            for (let i = 0; i < base32.length; i++) {
                const index = alphabet.indexOf(base32.charAt(i));
                if (index === -1) {
                    throw new Error(`Invalid base32 character: ${base32.charAt(i)}`);
                }
                bits += index.toString(2).padStart(5, '0');
            }
            
            // 将二进制字符串转换为Uint8Array
            const bytes = [];
            for (let i = 0; i + 8 <= bits.length; i += 8) {
                bytes.push(parseInt(bits.substr(i, 8), 2));
            }
            
            return new Uint8Array(bytes);
        }

        // HMAC-SHA1函数 - 复制自script.js
        async function hmacSHA1(key, message) {
            // 确保message是Uint8Array
            if (!(message instanceof Uint8Array)) {
                throw new Error('Message must be a Uint8Array');
            }
            
            // 确保key是Uint8Array
            if (typeof key === 'string') {
                const encoder = new TextEncoder();
                key = encoder.encode(key);
            }
            
            // 检查Web Crypto API是否可用
            if (typeof crypto !== 'undefined' && crypto.subtle) {
                // 使用Web Crypto API实现HMAC-SHA1
                try {
                    const importedKey = await crypto.subtle.importKey(
                        'raw',
                        key,
                        { name: 'HMAC', hash: { name: 'SHA-1' } },
                        false,
                        ['sign']
                    );
                    
                    const signature = await crypto.subtle.sign(
                        'HMAC',
                        importedKey,
                        message
                    );
                    
                    return new Uint8Array(signature);
                } catch (error) {
                    console.error('Web Crypto API HMAC-SHA1 error:', error);
                    // 如果Web Crypto API失败，尝试使用替代实现
                    return hmacSHA1Fallback(key, message);
                }
            } else {
                // Web Crypto API不可用时，使用替代实现
                return hmacSHA1Fallback(key, message);
            }
        }

        // HMAC-SHA1替代实现（当Web Crypto API不可用时使用）
        function hmacSHA1Fallback(key, message) {
            // 纯JavaScript SHA1实现
            function sha1(data) {
                // 转换为Uint8Array
                if (typeof data === 'string') {
                    const encoder = new TextEncoder();
                    data = encoder.encode(data);
                }
                
                // SHA1常量
                const K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
                
                // 初始化哈希值
                let h0 = 0x67452301;
                let h1 = 0xEFCDAB89;
                let h2 = 0x98BADCFE;
                let h3 = 0x10325476;
                let h4 = 0xC3D2E1F0;
                
                // 填充数据
                const originalLength = data.length * 8;
                let paddedData = new Uint8Array(data.length + 1 + ((64 - ((data.length + 1 + 8) % 64)) % 64) + 8);
                paddedData.set(data);
                paddedData[data.length] = 0x80;
                
                // 添加原始长度（大端序）
                for (let i = 0; i < 8; i++) {
                    paddedData[paddedData.length - 1 - i] = (originalLength >>> (i * 8)) & 0xFF;
                }
                
                // 处理512位块
                for (let i = 0; i < paddedData.length; i += 64) {
                    const block = paddedData.subarray(i, i + 64);
                    const w = new Array(80);
                    
                    // 前16个单词直接从块中获取
                    for (let t = 0; t < 16; t++) {
                        w[t] = (block[t * 4] << 24) | (block[t * 4 + 1] << 16) | (block[t * 4 + 2] << 8) | block[t * 4 + 3];
                    }
                    
                    // 扩展剩余的64个单词
                    for (let t = 16; t < 80; t++) {
                        w[t] = ((w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]) << 1) | ((w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]) >>> 31);
                    }
                    
                    // 初始化变量
                    let a = h0;
                    let b = h1;
                    let c = h2;
                    let d = h3;
                    let e = h4;
                    
                    // 主循环
                    for (let t = 0; t < 80; t++) {
                        let f, k;
                        if (t < 20) {
                            f = (b & c) | (~b & d);
                            k = K[0];
                        } else if (t < 40) {
                            f = b ^ c ^ d;
                            k = K[1];
                        } else if (t < 60) {
                            f = (b & c) | (b & d) | (c & d);
                            k = K[2];
                        } else {
                            f = b ^ c ^ d;
                            k = K[3];
                        }
                        
                        const temp = (((a << 5) | (a >>> 27)) + f + e + k + w[t]) & 0xFFFFFFFF;
                        e = d;
                        d = c;
                        c = ((b << 30) | (b >>> 2)) & 0xFFFFFFFF;
                        b = a;
                        a = temp;
                    }
                    
                    // 更新哈希值
                    h0 = (h0 + a) & 0xFFFFFFFF;
                    h1 = (h1 + b) & 0xFFFFFFFF;
                    h2 = (h2 + c) & 0xFFFFFFFF;
                    h3 = (h3 + d) & 0xFFFFFFFF;
                    h4 = (h4 + e) & 0xFFFFFFFF;
                }
                
                // 转换为Uint8Array
                const result = new Uint8Array(20);
                result[0] = (h0 >>> 24) & 0xFF;
                result[1] = (h0 >>> 16) & 0xFF;
                result[2] = (h0 >>> 8) & 0xFF;
                result[3] = h0 & 0xFF;
                result[4] = (h1 >>> 24) & 0xFF;
                result[5] = (h1 >>> 16) & 0xFF;
                result[6] = (h1 >>> 8) & 0xFF;
                result[7] = h1 & 0xFF;
                result[8] = (h2 >>> 24) & 0xFF;
                result[9] = (h2 >>> 16) & 0xFF;
                result[10] = (h2 >>> 8) & 0xFF;
                result[11] = h2 & 0xFF;
                result[12] = (h3 >>> 24) & 0xFF;
                result[13] = (h3 >>> 16) & 0xFF;
                result[14] = (h3 >>> 8) & 0xFF;
                result[15] = h3 & 0xFF;
                result[16] = (h4 >>> 24) & 0xFF;
                result[17] = (h4 >>> 16) & 0xFF;
                result[18] = (h4 >>> 8) & 0xFF;
                result[19] = h4 & 0xFF;
                
                return result;
            }
            
            // HMAC计算逻辑
            const blockSize = 64;
            const keyPadding = new Uint8Array(blockSize);
            
            // 调整密钥长度
            let adjustedKey = key;
            if (key.length > blockSize) {
                adjustedKey = sha1(key);
            }
            
            // 填充密钥
            keyPadding.set(adjustedKey);
            
            // 计算内层和外层密钥
            const innerKeyPad = new Uint8Array(blockSize);
            const outerKeyPad = new Uint8Array(blockSize);
            
            for (let i = 0; i < blockSize; i++) {
                innerKeyPad[i] = keyPadding[i] ^ 0x36;
                outerKeyPad[i] = keyPadding[i] ^ 0x5C;
            }
            
            // 计算内层哈希
            const innerData = new Uint8Array(innerKeyPad.length + message.length);
            innerData.set(innerKeyPad);
            innerData.set(message, innerKeyPad.length);
            const innerHash = sha1(innerData);
            
            // 计算外层哈希
            const outerData = new Uint8Array(outerKeyPad.length + innerHash.length);
            outerData.set(outerKeyPad);
            outerData.set(innerHash, outerKeyPad.length);
            const outerHash = sha1(outerData);
            
            return outerHash;
        }

        // 生成TOTP
        async function generateTOTP(secret, digits = 6, period = 30, timestamp = Date.now()) {
            // 将Base32密钥转换为二进制
            const decodedSecret = base32Decode(secret);
            
            // 获取当前时间步长
            const now = Math.floor(timestamp / 1000);
            const timeStep = Math.floor(now / period);
            
            // 将时间步长转换为8字节的缓冲区（大端序）
            const buffer = new ArrayBuffer(8);
            const view = new DataView(buffer);
            // 正确处理8字节时间步长（大端序）
            // 使用BigInt确保正确处理大数值
            let bigTimeStep = BigInt(timeStep);
            for (let i = 0; i < 8; i++) {
                view.setUint8(7 - i, Number((bigTimeStep >> BigInt(i * 8)) & 0xFFn));
            }
            
            // 计算HMAC-SHA1
            const hmac = await hmacSHA1(decodedSecret, new Uint8Array(buffer));
            
            // 动态截断
            const offset = hmac[hmac.length - 1] & 0x0F;
            const code = ((hmac[offset] & 0x7F) << 24) |
                         ((hmac[offset + 1] & 0xFF) << 16) |
                         ((hmac[offset + 2] & 0xFF) << 8) |
                         (hmac[offset + 3] & 0xFF);
            
            // 取模得到指定长度的验证码
            const otp = code % Math.pow(10, digits);
            
            // 补前导零
            return otp.toString().padStart(digits, '0');
        }

        // 辅助函数
        function arrayToHex(array) {
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        }

        function updateTimeInfo() {
            const now = new Date();
            const timestamp = Date.now();
            const timestep = Math.floor(timestamp / 1000 / 30);
            
            document.getElementById('current-time').textContent = now.toLocaleString();
            document.getElementById('current-timestamp').textContent = timestamp;
            document.getElementById('current-timestep').textContent = timestep;
        }

        // 测试函数
        async function runTests() {
            updateTimeInfo();
            
            const testResults = document.getElementById('test-results');
            testResults.innerHTML = '';
            
            // 测试用例
            const testCases = [
                {
                    name: '测试1 - 简单密钥',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: Date.now()
                },
                {
                    name: '测试2 - 另一个密钥',
                    secret: 'GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ',
                    timestamp: Date.now()
                },
                {
                    name: '测试3 - 固定时间',
                    secret: 'JBSWY3DPEHPK3PXP',
                    timestamp: 1609459200000 // 2021-01-01 00:00:00 UTC
                }
            ];
            
            for (const testCase of testCases) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'test-case';
                resultDiv.innerHTML = `<h3>${testCase.name}</h3>`;
                
                try {
                    // 使用Web Crypto API生成TOTP
                    const cryptoTOTP = await generateTOTP(testCase.secret, 6, 30, testCase.timestamp);
                    
                    // 强制使用替代实现生成TOTP
                    const originalHmac = window.hmacSHA1;
                    window.hmacSHA1 = function(key, message) {
                        return Promise.resolve(hmacSHA1Fallback(key, message));
                    };
                    
                    const fallbackTOTP = await generateTOTP(testCase.secret, 6, 30, testCase.timestamp);
                    
                    // 恢复原始函数
                    window.hmacSHA1 = originalHmac;
                    
                    const isConsistent = cryptoTOTP === fallbackTOTP;
                    
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'test-info';
                    infoDiv.innerHTML = `
                        <p>密钥: ${testCase.secret}</p>
                        <p>时间戳: ${testCase.timestamp}</p>
                        <p>Web Crypto API TOTP: ${cryptoTOTP}</p>
                        <p>替代实现 TOTP: ${fallbackTOTP}</p>
                        <p>结果: ${isConsistent ? '一致' : '不一致'}</p>
                    `;
                    
                    resultDiv.appendChild(infoDiv);
                    
                    if (isConsistent) {
                        resultDiv.classList.add('pass');
                    } else {
                        resultDiv.classList.add('fail');
                    }
                } catch (error) {
                    resultDiv.classList.add('fail');
                    resultDiv.innerHTML += `<p>错误: ${error.message}</p>`;
                    console.error('测试错误:', error);
                }
                
                testResults.appendChild(resultDiv);
            }
        }
        
        // 初始更新时间
        updateTimeInfo();
        setInterval(updateTimeInfo, 1000);
    </script>
</body>
</html>